{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"M\u00f3dulo RK4 Este m\u00f3dulo implementa el m\u00e9todo de integraci\u00f3n Runge-Kutta de orden 4. Esta es una t\u00e9cnica num\u00e9rica para resolver ecuaciones diferenciales de primer orde. La aplicaci\u00f3n que se le da a este m\u00f3dulo es en un problema din\u00e1mico de valor inicial.","title":"Home"},{"location":"#modulo-rk4","text":"Este m\u00f3dulo implementa el m\u00e9todo de integraci\u00f3n Runge-Kutta de orden 4. Esta es una t\u00e9cnica num\u00e9rica para resolver ecuaciones diferenciales de primer orde. La aplicaci\u00f3n que se le da a este m\u00f3dulo es en un problema din\u00e1mico de valor inicial.","title":"M\u00f3dulo RK4"},{"location":"explanation/","text":"M\u00e9todo Runge-Kutta de orden 4 (RK4) En general, un modelo din\u00e1mico intenta resolver la trayectoria temporal de alguna cantidad f\u00edsica como funci\u00f3n de alg\u00fan generador din\u00e1mico; este \u00faltimo usualmente representado de forma funcional. En algunos casos, podemos modelar la din\u00e1mica de un estado gen\u00e9rico \\(y\\) mediante la ecuaci\u00f3n din\u00e1mica \\begin{equation} \\frac{dy}{dt} = f(t, y), \\end{equation} sujeta a la condici\u00f3n inicial \\begin{equation} y(t_0) = y_0. \\end{equation} En esta notaci\u00f3n, \\(y\\) corresponde a un estado del sistema. Este estado puede ser representado mediante diferentes objetos matem\u00e1ticos: desde cantidades escalares hasta matrices que representan cierto operador lineal. En la ecuaci\u00f3n anterior, \\(t\\) corresponde a la variable temporal. El problema din\u00e1mico descrito anteriormente es usualmente conocido en el campo de las matem\u00e1ticas aplicadas como problema de condici\u00f3n inicial . El m\u00e9todo Runge-Kutta de orden 4 (RK4) sirve para estimar la soluci\u00f3n a un punto temporal \\(y_n\\) . Tenemos: \\[\\begin{aligned} y_{n+1} &= y_n + \\frac{1}{6} \\left(k_1 + 2k_2 + 2k_3 + k_4\\right) \\quad \\\\ k_1 &= h f(t_n, y_n) \\quad \\\\ k_2 &= h f\\left(t_n + \\frac{h}{2}, y_n + \\frac{k_1}{2}\\right)\\quad \\\\ k_3 &= h f\\left(t_n + \\frac{h}{2}, y_n + \\frac{k_2}{2}\\right)\\quad \\\\ k_4 &= h f\\left(t_n + h, y_n k_3\\right) \\quad \\\\ \\end{aligned}\\] donde \\(\\textit{h}\\) corresponde al espaciamiento temporal.","title":"Explanation"},{"location":"explanation/#metodo-runge-kutta-de-orden-4-rk4","text":"En general, un modelo din\u00e1mico intenta resolver la trayectoria temporal de alguna cantidad f\u00edsica como funci\u00f3n de alg\u00fan generador din\u00e1mico; este \u00faltimo usualmente representado de forma funcional. En algunos casos, podemos modelar la din\u00e1mica de un estado gen\u00e9rico \\(y\\) mediante la ecuaci\u00f3n din\u00e1mica \\begin{equation} \\frac{dy}{dt} = f(t, y), \\end{equation} sujeta a la condici\u00f3n inicial \\begin{equation} y(t_0) = y_0. \\end{equation} En esta notaci\u00f3n, \\(y\\) corresponde a un estado del sistema. Este estado puede ser representado mediante diferentes objetos matem\u00e1ticos: desde cantidades escalares hasta matrices que representan cierto operador lineal. En la ecuaci\u00f3n anterior, \\(t\\) corresponde a la variable temporal. El problema din\u00e1mico descrito anteriormente es usualmente conocido en el campo de las matem\u00e1ticas aplicadas como problema de condici\u00f3n inicial . El m\u00e9todo Runge-Kutta de orden 4 (RK4) sirve para estimar la soluci\u00f3n a un punto temporal \\(y_n\\) . Tenemos: \\[\\begin{aligned} y_{n+1} &= y_n + \\frac{1}{6} \\left(k_1 + 2k_2 + 2k_3 + k_4\\right) \\quad \\\\ k_1 &= h f(t_n, y_n) \\quad \\\\ k_2 &= h f\\left(t_n + \\frac{h}{2}, y_n + \\frac{k_1}{2}\\right)\\quad \\\\ k_3 &= h f\\left(t_n + \\frac{h}{2}, y_n + \\frac{k_2}{2}\\right)\\quad \\\\ k_4 &= h f\\left(t_n + h, y_n k_3\\right) \\quad \\\\ \\end{aligned}\\] donde \\(\\textit{h}\\) corresponde al espaciamiento temporal.","title":"M\u00e9todo Runge-Kutta de orden 4 (RK4)"},{"location":"reference/","text":"Referencias Referencia de las funciones del m\u00f3dulo RK4. ::: RK4.RK4","title":"Referencias"},{"location":"reference/#referencias","text":"Referencia de las funciones del m\u00f3dulo RK4. ::: RK4.RK4","title":"Referencias"},{"location":"tutorials/","text":"Tutorial A continuaci\u00f3n se presenta un ejemplo de implementaci\u00f3n del m\u00e9todo RK4 para resolver un problema din\u00e1mico. #Se importan las librer\u00edas necesarias para la ejecuci\u00f3n import numpy as np import matplotlib.pyplot as plt Funci\u00f3n para la evoluci\u00f3n temporal (ver referencia) def dyn_generator(oper, state): return -1.0j*(np.dot(oper,state)-np.dot(state,oper)) #Funci\u00f3n para implementar RK4 (ver referencia) def rk4(func, oper, state, h): k_1 = h*func(oper,state) k_2 = h*func(oper,state+((k_1)/2)) k_3 = h*func(oper,state+((k_2)/2)) k_4 = h*func(oper,state+k_3) return state + (k_1 + 2*k_2 + 2*k_3 + k_4)*(1/6) #Se define el operador lineal oOper = np.array([[0, 1], [1, 0]]) #Se establece un estado inicial para el sistema yInit = np.array([[1, 0], [0, 0]]) #Se define un rango para el tiempo de variaci\u00f3n del estado que determina el espaciamiento temporal tFinal = 10.0 times = np.linspace(0,tFinal,10000) h = times[1]-times[0] #Se definen dos arreglos para almacenar el cambio de estado del sistema. stateQuant00 = np.zeros(times.size) stateQuant11 = np.zeros(times.size) #Se elabora un ciclo para guardar el cambio de estado a trav\u00e9s de dyn_generator estimado por RK4 for t in range(times.size): stateQuant00[t] = yInit[0, 0].real stateQuant11[t] = yInit[1, 1].real yN = rk4(dyn_generator, oOper, yInit, h) yInit = yN #Por \u00faltimo se grafican los cambios en el estado en funcion del tiempo plt.plot(times, stateQuant00) plt.plot(times, stateQuant11) plt.xlabel('Tiempo') plt.ylabl('Estado') plt.show","title":"Tutorial"},{"location":"tutorials/#tutorial","text":"A continuaci\u00f3n se presenta un ejemplo de implementaci\u00f3n del m\u00e9todo RK4 para resolver un problema din\u00e1mico. #Se importan las librer\u00edas necesarias para la ejecuci\u00f3n import numpy as np import matplotlib.pyplot as plt Funci\u00f3n para la evoluci\u00f3n temporal (ver referencia) def dyn_generator(oper, state): return -1.0j*(np.dot(oper,state)-np.dot(state,oper)) #Funci\u00f3n para implementar RK4 (ver referencia) def rk4(func, oper, state, h): k_1 = h*func(oper,state) k_2 = h*func(oper,state+((k_1)/2)) k_3 = h*func(oper,state+((k_2)/2)) k_4 = h*func(oper,state+k_3) return state + (k_1 + 2*k_2 + 2*k_3 + k_4)*(1/6) #Se define el operador lineal oOper = np.array([[0, 1], [1, 0]]) #Se establece un estado inicial para el sistema yInit = np.array([[1, 0], [0, 0]]) #Se define un rango para el tiempo de variaci\u00f3n del estado que determina el espaciamiento temporal tFinal = 10.0 times = np.linspace(0,tFinal,10000) h = times[1]-times[0] #Se definen dos arreglos para almacenar el cambio de estado del sistema. stateQuant00 = np.zeros(times.size) stateQuant11 = np.zeros(times.size) #Se elabora un ciclo para guardar el cambio de estado a trav\u00e9s de dyn_generator estimado por RK4 for t in range(times.size): stateQuant00[t] = yInit[0, 0].real stateQuant11[t] = yInit[1, 1].real yN = rk4(dyn_generator, oOper, yInit, h) yInit = yN #Por \u00faltimo se grafican los cambios en el estado en funcion del tiempo plt.plot(times, stateQuant00) plt.plot(times, stateQuant11) plt.xlabel('Tiempo') plt.ylabl('Estado') plt.show","title":"Tutorial"}]}